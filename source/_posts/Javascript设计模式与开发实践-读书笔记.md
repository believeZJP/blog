---
title: Javascript设计模式与开发实践-读书笔记
date: 2019-02-13 14:20:04
updated: 2019-02-13 14:20:04
tags:
- Javascript
- 设计模式
- 读书笔记
---
读《JavaScript设计模式与开发实践》笔记摘要

# 设计模式定义

设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。
通俗的说：
设计模式是在某种场合下对某个问题的一种解决方案。
设计模式是给面向对象软件开发中的一些好的设计取的名字。

在软件设计中，模式是一些经过了大量实际项目验证的优秀解决方案。
熟悉这些模式 的程序员，对某些模式的理解也许形成了条件反射。当合适的场景出现时，他们可以很快地找到 某种模式作为解决方案。

## 设计模式的主题总是把不变的事物和变化的事物分离开

## 作用

让人们写出可复用和可维护性高的程序.

所有设计模式都遵循一条原则，即'找出程序中变化的地方，并将变化封装起来'。
一个程序的设计总是可以分为可变的部分和不变的部分。当我们找出可变的部分，并且把这些部 分封装起来，那么剩下的就是不变和稳定的部分。
这些不变和稳定的部分是非常容易复用的。这 也是设计模式为什么描写的是可复用面向对象软件基础的原因。

设计模式被人误解的一个重要原因是人们对它的误用和滥用，比如将一些模式用在了错误的 场景中，或者说在不该使用模式的地方刻意使用模式。

## 分辨模式的关键是意图而不是结构

在设计模式的学习中，有人经常发出这样的疑问:
代理模式和装饰者模式，策略模式和状态 模式，策略模式和智能命令模式，这些模式的类图看起来几乎一模一样，它们到底有什么区别?

辨别模式的关键是这个模式出现的场景，以及为我们解决了什么问题。

## 对JavaScript设计模式的误解

一些资料中对JavaScript模式存在的两个问题:

1. 第一个问题是习惯把静态类型语言的设计模式照搬到JavaScript中.

    比如有人为了模拟 JavaScript版本的工厂方法(Factory Method)模式，而生硬地把创建对象的步骤延迟到子类中。
    实际上，在Java等静态类型语言中，让子类来“决定”创建何种对象的原因是为了让程序迎合依赖倒置原则(DIP)。
    在这些语言中创建对象时，先解开对象类型之间的耦合关系非常重要，这样才有机会在将来让对象表现出多态性。
    而在JavaScript这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另外一个类。
    JavaScript不存在类型耦合的问题，自然也没有必要刻意去把对象“延迟”到子类创建，也就是说，JavaScript实际上是不需要工厂方法模式的。
    模式的存在首先是能为我们解决什么问题，这种牵强的模拟只会让人觉得设计模式既难懂又没什么用处。

2. 另一个问题是习惯根据模式的名字去臆测该模式的一切。

    比如命令模式本意是把请求封装到对象中，利用命令模式可以解开请求发送者和请求接受者之间的耦合关系。
    但命令模式经常被人误解为只是一个名为execute的普通方法调用。这个方法除了叫作execute之外，其实并没有看出其他用处。
    所以许多人会误会命令模式的意图，以为它其实没什么用处，从而联想到其他设计模式 也没有用处。

这些误解都影响了设计模式在JavaScript语言中的发展。

JavaScript中的原型继承

1. 所有的数据都是对象
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
    JavaScript的根对象是Object.prototype对象。

    ```js
    var obj1 = new Object();
    var obj2 = {};

    console.log(Object.getPrototypeOf(obj1) === Object.prototype); // true
    console.log(Object.getPrototypeOf(obj2) === Object.prototype); // true
    ```

3. JavaScript对象会记住它的原型
4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型

## 工厂模式列表

1. 抽象工厂模式（Abstract Factory）
    定义: 提供一个创建一系列相关或相互依赖对象的接口，而无需制定它们具体的类。
    本质: 选择产品簇的实现。
2. 生成器模式（Builder）
    定义: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    本质：
        分离整体构建算法和部件构造。
        生成器模式的重心在于分离整体构建算法和部件构造，而分步骤构建对象不过是整体构建算法的一个简单实现，或者说是一个附带产物。

生成器模式与抽象工厂模式

这两个模式既相似又有区别，也可以组合使用。
    区别：抽象工厂模式的主要目的是创建产品簇，这个产品簇里面的单个产品就相当于是构成一个复杂对象的部件对象，抽象工厂对象创建完成后就立即返回整个产品簇；而生成器模式的主要目的是按照构造算法，一步一步来构建一个复杂的产品对象，桐城要等到整个构建过程结束以后没才会得到最终的产品对象。

组合使用：在生成器模式的Builder实现中，需要创建各个部件对象，而这些部件对象是有关联的，通常是构成一个复杂对象的部件对象。也就是说，Builder实现中，需要获取构成一个复杂对象的产品簇，就可以使用抽象工厂模式来实现。有抽象工厂模式负责部件对象创建，Builder实现里面则主要负责产品对象整体的构建了。

## 策略模式

策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。

```js
var strategies = {
    "S": function( salary ){
        return salary * 4;
    },
    "A": function( salary ){
        return salary * 3;
    },
    "B": function( salary ){
        return salary * 2;
    };
var calculateBonus = function(level, salary){
    return strategies[level](salary);
};
console.log(calculateBonus('S', 20000));
console.log(calculateBonus('A', 10000));
// 输出:80000 // 输出:30000
```

## 发布-订阅模式

发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。

优点：

一为时间上的解耦
二为对象之间的解耦。
还可以用来帮助实现一些别的设计模式，比如中介者模式。

缺点:

创建订阅者本身要消耗一定的时间和内存.
发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。
特别是有多个发布者和订阅者嵌套到一 起的时候，要跟踪一个 bug 不是件轻松的事情。

## 组合模式

组合模式: 用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更 小的“孙对象”构成的。

组合对象和叶对象会各自做自己正确的事情。--组合模式最重要的能力

使用场景：
    1. 代表对象的部分-整体层次结构。
    2. 对树中所有对象统一对待

组合模式可以让我们使用树形方式创建对象的结构，把相同的操作应用在组合对象和单个对象上。大多数情况下可以忽略掉两者的差别，用一致的方式来处理。

缺点：

每个对象看你起来与其他对象差不多，但区别会在运行时显现出来，会让代码难以理解；
    如果组合模式创建的对象太多，可能让系统负担不起。

## 模板方法模式(Template Method)

模板方法模式是一种只需使用继承就可以实现的非常简单的模式。

模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。
通常 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。
子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。

如果子类未实现父类要求实现的方法，可以`throw new Error('子类必须重写xxx方法')`来做检查。

模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。

```js
var brew = param.brew || function(){
    throw new Error( '必须传递 brew 方法' );
};
```

模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架， 程序员继承框架的结构之后，负责往里面填空，

钩子方法(hook)用来解决一些特殊的子类，不符合父类的执行顺序等。

## 享元模式(flyweight)

是一种用时间换空间的优化模式，为解决性能而生

核心: 运用共享技术来有效支持大量细粒度的对象

目标: 尽量减少共享对象的数量

享元模式要求将对象的属性分为内部状态和外部状态。划分内外部状态规则：

- 内部状态存储于对象内部
- 内部状态可以被一些对象共享
- 内部状态独立于具体的场景，通常不会变
- 外部状态取决于具体的场景，根据场景而变，外部状态不能共享

使用场景：

- 一个程序中使用了大量的相似对象
- 由于使用了大量的相似对象，造成很大的内存开销
- 对象的大多数状态都可以变为外部状态
- 剥离出对象的外部状态后，可以用相对较少的共享对象取代大量对象

思考：

创建出的共享对象在每次绑定事件后会执行自己的绑定时间还是会覆盖

## 职责链模式

定义: 使多个对象都有机会处理请求，避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，
连着这条链传递该请求，直到有一个对象处理它为止。

把大函数拆成小函数，去掉许多嵌套的条件分支语句

此外 Chain 的 prototype 中还有两个函数，它们的作用如下所示: // Chain.prototype.setNextSuccessor 指定在链中的下一个节点
// Chain.prototype.passRequest 传递请求给某个节点

```js
var Chain = function( fn ){
    this.fn = fn;
    this.successor = null;
};
Chain.prototype.setNextSuccessor = function( successor ){
    return this.successor = successor;
};
Chain.prototype.passRequest = function(){
    var ret = this.fn.apply( this, arguments );
    if ( ret === 'nextSuccessor' ){
        return this.successor && this.successor.passRequest.apply( this.successor, arguments );
    }
    return ret;
};


// 使用
var chainOrder500 = new Chain( order500 );
var chainOrder200 = new Chain( order200 );
var chainOrderNormal = new Chain( orderNormal );

chainOrder500.setNextSuccessor( chainOrder200 );
chainOrder200.setNextSuccessor( chainOrderNormal);

```

优点：

- 解耦了请求发送者和N个接收者之间的复杂关系

- 链中的节点可以灵活的拆分重组

- 可以手动指定起始节点

- 可以在链尾增加一个保底的接受者节点处理前面无法处理的请求

要避免过长的职责链带来的性能损耗

## 中介者模式

通过增加一个中介者对象，所有相关的对象都通过中介者来通信，而不是互相引用。当一个对象发生改变，只需通知中介者。

使网状的多对多关系变成相对简单的一对多关系

**作用**
    解除对象与对象之间的紧耦合关系。

**缺点**
    系统会增加一个中介者对象。对象之间复杂的交互性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身就是一个难以维护的对象。

**总结**
中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。

## 装饰者模式

动态的给某个对象添加一些额外的职责，而不会影响这个类中派生的其他对象。

装饰者能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。

传统语言中，给对象添加功能常用继承方式，但继承会带来以下问题:
    1. 导致子类和超类之间存在强耦合性， 超类改变，子类也随之改变
    2. 继承的复用方式是白箱复用，超类的内部细节对子类可见。继承常常被认为破坏了封装性。
    3. 完成功能复用时，有可能创造出大量的子类。

装饰者模式跟继承者模式相比更轻便灵活。

代理者模式和装饰者模式区别

在于他们的意图和设计目的

代理模式的目的是直接访问本体不方便或不需要时，提供一个替代者，本体定义了关键功能。代理者模式强调一种关系(proxy和它本体之间的关系), 这种关系可以静态的表达。这种关系一开始就可以确定。
而装饰器模式用于一开始不能确定对象的全部功能时。

代理模式通常只有一层代理-本体的引用，装饰者模式会形成一条长长的链条。

## 状态模式

**定义**
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

我们以逗号分割，把这句话分为两部分来看。第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。
第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这 个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。

状态模式的关键是区分事物内部的状态，事物内部状态的改变，往往会带来事物行为的改变。

把事物的每个状态都封装成单独的类，跟此种状态有关的行为都封装在这个类的内部。
要修改时，把请求委托给当前的状态对象即可，该状态对象负责执行相应的方法。

### 优点

- 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。
- 避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过 5 多的条件分支。
- 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。
- Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。

### 缺点

会在系统中定义许多状态类，系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。

### 性能优化

管理 state 对象的创建和销毁。

第一种是仅当 state 对象被需要时才创建并随后销毁，
另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。
如果 state 对象比较庞大，可以用第一种方式来节省内存，
这样可以避免创建一些不会用到的对象并及时地回收它们。

### 状态模式和策略模式区别

相同点

它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。

区别

策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系， 所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法;而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。

## 适配器模式

当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。
两种解决办法，第一种是修改原来的接口实现。
第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。

### 适配器作用

解决两个软件间的接口不兼容的问题。

### 适配器和其他模式的区别

关键仍然是模式的意图

- 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。
- 装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。
- 外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外 观模式最显著的特点是定义了一个新的接口。

## 设计原则和编程技巧

## 单一职责原则SRP(Single Responsibility Principle)

一个对象(方法)只做一件事情。

SRP 原则在很多设计模式中都有着广泛的运用，例如代理模式、迭代器模式、单例模式和装饰者模式。

要明确的是，并不是所有的职责都应该一一分离。
一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。

另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。

在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而 是要取决于具体的应用环境。

### SRP 原则的优缺点

优点

降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度， 这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。

缺点

最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。

## 最少知识原则(LKP)

一个软件实体应当尽可能少地与其他实体发生相互作用。

例如：中介者模式和外观模式。

终结者模式：通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。

外观模式：为一组子系统提供一个简单便利的访问入口, 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。

封装：封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口 API 供外界访问。对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内。

虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难 以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则， 要根据具体的环境来定。

## 开放封闭原则(OCP)

当需要改变一个程序的功能或者给这个程序增加新功 能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。

### 用对象的多态性消除条件分支

过多的条件分支语句是造成程序违反开放封闭原则的一个常见原因。每当需要增加一个新的 if 语句时，都要被迫改动原函数。把 if 换成 switch-case 是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的 if 或者 swtich-case 语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。

利用对象的多态性来让程序遵守开放封闭原则，是一个常用的技巧。

找到一些让程序尽量遵守开放封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。

### 其他方式

1. 放置挂钩(hook)
    在程序有可能发生变化的地方放置挂钩，挂钩返回的结果决定程序下一步走向。

2. 使用回调函数
    策略模式和命令模式等都可以用回调函数轻松实现。

<!-- TODO -->

## 代码重构

1. 提炼函数
   函数要有良好的命名，函数体内包含的逻辑清晰明了。
   好处
   - 避免出现超大函数。
   - 独立出来的函数有助于代码复用。
   - 独立出来的函数更容易被覆写。
   - 独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用。

2. 合并重复的条件片段
3. 把条件分支语句提炼成函数

    ```js
    if ( date.getMonth() >= 6 && date.getMonth() <= 9 ){ // ...
    }
    // 提炼出来
    var isSummer = function(){
        var date = new Date();
        return date.getMonth() >= 6 && date.getMonth() <= 9;
    };

    if (isSummer) {
        // ...
    }
    ```

4. 合理使用循环

5. 提前让函数退出代替嵌套条件分支

6. 传递对象参数代替过长的参数列表
可以把参数都放入一个对象内
7. 尽量减少参数数量
8. 少用三目运算符
9. 少用三目运算符
10. 分解大型类
11. 用return退出多重循环

[链接](https://www.cnblogs.com/tugenhua0707/p/5198407.html)

## 工厂模式

简单的工厂模式可以理解为解决多个相似的问题;

```js
function CreatePerson(name,age,sex) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.sex = sex;
    obj.sayName = function(){
        return this.name;
    }
    return obj;
}
var p1 = new CreatePerson("longen",'28','男');
var p2 = new CreatePerson("tugenhua",'27','女');
console.log(p1.name); // longen
console.log(p1.age);  // 28
console.log(p1.sex);  // 男
console.log(p1.sayName()); // longen

console.log(p2.name);  // tugenhua
console.log(p2.age);   // 27
console.log(p2.sex);   // 女
console.log(p2.sayName()); // tugenhua  
```

## 单例模式

只能被实例化(构造函数给实例添加属性与方法)一次

```js
// 单体模式
var Singleton = function(name){
    this.name = name;
};
Singleton.prototype.getName = function(){
    return this.name;
}
// 获取实例对象
var getInstance = (function() {
    var instance = null;
    return function(name) {
        if(!instance) {//相当于一个一次性阀门,只能实例化一次
            instance = new Singleton(name);
        }
        return instance;
    }
})();
// 测试单体模式的实例,所以a===b
var a = getInstance("aa");
var b = getInstance("bb");  
```

## 沙箱模式

将一些函数放到自执行函数里面,但要用闭包暴露接口,用变量接收暴露的接口,再调用里面的值,否则无法使用里面的值

```js
let sandboxModel=(function(){
    function sayName(){};
    function sayAge(){};
    return{
        sayName:sayName,
        sayAge:sayAge
    }
})()
```

## 发布者订阅模式

就例如如我们关注了某一个公众号,然后他对应的有新的消息就会给你推送,

代码实现逻辑是用数组存贮订阅者, 发布者回调函数里面通知的方式是遍历订阅者数组,并将发布者内容传入订阅者数组

```js
//发布者与订阅模式
var shoeObj = {}; // 定义发布者
shoeObj.list = []; // 缓存列表 存放订阅者回调函数

// 增加订阅者
shoeObj.listen = function(fn) {
    shoeObj.list.push(fn); // 订阅消息添加到缓存列表
}

// 发布消息
shoeObj.trigger = function() {
        for (var i = 0, fn; fn = this.list[i++];) {
            fn.apply(this, arguments);//第一个参数只是改变fn的this,
        }
    }
 // 小红订阅如下消息
shoeObj.listen(function(color, size) {
    console.log("颜色是：" + color);
    console.log("尺码是：" + size);
});

// 小花订阅如下消息
shoeObj.listen(function(color, size) {
    console.log("再次打印颜色是：" + color);
    console.log("再次打印尺码是：" + size);
});
shoeObj.trigger("红色", 40);
shoeObj.trigger("黑色", 42);  
```
