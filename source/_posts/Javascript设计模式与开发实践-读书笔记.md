---
title: Javascript设计模式与开发实践-读书笔记
date: 2019-02-13 14:20:04
updated: 2019-02-13 14:20:04
tags:
- Javascript
- 设计模式
- 读书笔记
---
读《JavaScript设计模式与开发实践》笔记摘要

# 设计模式定义

设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。
通俗的说：
设计模式是在某种场合下对某个问题的一种解决方案。
设计模式是给面向对象软件开发中的一些好的设计取的名字。

在软件设计中，模式是一些经过了大量实际项目验证的优秀解决方案。
熟悉这些模式 的程序员，对某些模式的理解也许形成了条件反射。当合适的场景出现时，他们可以很快地找到 某种模式作为解决方案。

## 作用

让人们写出可复用和可维护性高的程序.

所有设计模式都遵循一条原则，即'找出程序中变化的地方，并将变化封装起来'。
一个程序的设计总是可以分为可变的部分和不变的部分。当我们找出可变的部分，并且把这些部 分封装起来，那么剩下的就是不变和稳定的部分。
这些不变和稳定的部分是非常容易复用的。这 也是设计模式为什么描写的是可复用面向对象软件基础的原因。

设计模式被人误解的一个重要原因是人们对它的误用和滥用，比如将一些模式用在了错误的 场景中，或者说在不该使用模式的地方刻意使用模式。

## 分辨模式的关键是意图而不是结构

在设计模式的学习中，有人经常发出这样的疑问:
代理模式和装饰者模式，策略模式和状态 模式，策略模式和智能命令模式，这些模式的类图看起来几乎一模一样，它们到底有什么区别?

辨别模式的关键是这个模式出现的场景，以及为我们解决了什么问题。

## 对JavaScript设计模式的误解

一些资料中对JavaScript模式存在的两个问题:

1. 第一个问题是习惯把静态类型语言的设计模式照搬到JavaScript中.

    比如有人为了模拟 JavaScript版本的工厂方法(Factory Method)模式，而生硬地把创建对象的步骤延迟到子类中。
    实际上，在Java等静态类型语言中，让子类来“决定”创建何种对象的原因是为了让程序迎合依赖倒置原则(DIP)。
    在这些语言中创建对象时，先解开对象类型之间的耦合关系非常重要，这样才有机会在将来让对象表现出多态性。
    而在JavaScript这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另外一个类。
    JavaScript不存在类型耦合的问题，自然也没有必要刻意去把对象“延迟”到子类创建，也就是说，JavaScript实际上是不需要工厂方法模式的。
    模式的存在首先是能为我们解决什么问题，这种牵强的模拟只会让人觉得设计模式既难懂又没什么用处。

2. 另一个问题是习惯根据模式的名字去臆测该模式的一切。

    比如命令模式本意是把请求封装到对象中，利用命令模式可以解开请求发送者和请求接受者之间的耦合关系。
    但命令模式经常被人误解为只是一个名为execute的普通方法调用。这个方法除了叫作execute之外，其实并没有看出其他用处。
    所以许多人会误会命令模式的意图，以为它其实没什么用处，从而联想到其他设计模式 也没有用处。

这些误解都影响了设计模式在JavaScript语言中的发展。

JavaScript中的原型继承

1. 所有的数据都是对象
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
    JavaScript的根对象是Object.prototype对象。

    ```js
    var obj1 = new Object();
    var obj2 = {};

    console.log(Object.getPrototypeOf(obj1) === Object.prototype); // true
    console.log(Object.getPrototypeOf(obj2) === Object.prototype); // true
    ```

3. JavaScript对象会记住它的原型
4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型

## 工厂模式列表

1. 抽象工厂模式（Abstract Factory）
    定义: 提供一个创建一系列相关或相互依赖对象的接口，而无需制定它们具体的类。
    本质: 选择产品簇的实现。
2. 生成器模式（Builder）
    定义: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    本质：
        分离整体构建算法和部件构造。
        生成器模式的重心在于分离整体构建算法和部件构造，而分步骤构建对象不过是整体构建算法的一个简单实现，或者说是一个附带产物。

生成器模式与抽象工厂模式

这两个模式既相似又有区别，也可以组合使用。
    区别：抽象工厂模式的主要目的是创建产品簇，这个产品簇里面的单个产品就相当于是构成一个复杂对象的部件对象，抽象工厂对象创建完成后就立即返回整个产品簇；而生成器模式的主要目的是按照构造算法，一步一步来构建一个复杂的产品对象，桐城要等到整个构建过程结束以后没才会得到最终的产品对象。

    组合使用：在生成器模式的Builder实现中，需要创建各个部件对象，而这些部件对象是有关联的，通常是构成一个复杂对象的部件对象。也就是说，Builder实现中，需要获取构成一个复杂对象的产品簇，就可以使用抽象工厂模式来实现。有抽象工厂模式负责部件对象创建，Builder实现里面则主要负责产品对象整体的构建了。

## 策略模式

策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。

```js
var strategies = {
    "S": function( salary ){
        return salary * 4;
    },
    "A": function( salary ){
        return salary * 3;
    },
    "B": function( salary ){
        return salary * 2;
    };
var calculateBonus = function(level, salary){
    return strategies[level](salary);
};
console.log(calculateBonus('S', 20000));
console.log(calculateBonus('A', 10000));
// 输出:80000 // 输出:30000
```