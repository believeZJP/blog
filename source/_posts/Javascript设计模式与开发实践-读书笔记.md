---
title: Javascript设计模式与开发实践-读书笔记
date: 2019-02-13 14:20:04
updated: 2019-02-13 14:20:04
tags:
- Javascript
- 设计模式
- 读书笔记
---
读《JavaScript设计模式与开发实践》笔记摘要

# 设计模式定义

设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。
通俗的说：
设计模式是在某种场合下对某个问题的一种解决方案。
设计模式是给面向对象软件开发中的一些好的设计取的名字。

在软件设计中，模式是一些经过了大量实际项目验证的优秀解决方案。
熟悉这些模式 的程序员，对某些模式的理解也许形成了条件反射。当合适的场景出现时，他们可以很快地找到 某种模式作为解决方案。

## 设计模式的主题总是把不变的事物和变化的事物分离开

## 作用

让人们写出可复用和可维护性高的程序.

所有设计模式都遵循一条原则，即'找出程序中变化的地方，并将变化封装起来'。
一个程序的设计总是可以分为可变的部分和不变的部分。当我们找出可变的部分，并且把这些部 分封装起来，那么剩下的就是不变和稳定的部分。
这些不变和稳定的部分是非常容易复用的。这 也是设计模式为什么描写的是可复用面向对象软件基础的原因。

设计模式被人误解的一个重要原因是人们对它的误用和滥用，比如将一些模式用在了错误的 场景中，或者说在不该使用模式的地方刻意使用模式。

## 分辨模式的关键是意图而不是结构

在设计模式的学习中，有人经常发出这样的疑问:
代理模式和装饰者模式，策略模式和状态 模式，策略模式和智能命令模式，这些模式的类图看起来几乎一模一样，它们到底有什么区别?

辨别模式的关键是这个模式出现的场景，以及为我们解决了什么问题。

## 对JavaScript设计模式的误解

一些资料中对JavaScript模式存在的两个问题:

1. 第一个问题是习惯把静态类型语言的设计模式照搬到JavaScript中.

    比如有人为了模拟 JavaScript版本的工厂方法(Factory Method)模式，而生硬地把创建对象的步骤延迟到子类中。
    实际上，在Java等静态类型语言中，让子类来“决定”创建何种对象的原因是为了让程序迎合依赖倒置原则(DIP)。
    在这些语言中创建对象时，先解开对象类型之间的耦合关系非常重要，这样才有机会在将来让对象表现出多态性。
    而在JavaScript这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另外一个类。
    JavaScript不存在类型耦合的问题，自然也没有必要刻意去把对象“延迟”到子类创建，也就是说，JavaScript实际上是不需要工厂方法模式的。
    模式的存在首先是能为我们解决什么问题，这种牵强的模拟只会让人觉得设计模式既难懂又没什么用处。

2. 另一个问题是习惯根据模式的名字去臆测该模式的一切。

    比如命令模式本意是把请求封装到对象中，利用命令模式可以解开请求发送者和请求接受者之间的耦合关系。
    但命令模式经常被人误解为只是一个名为execute的普通方法调用。这个方法除了叫作execute之外，其实并没有看出其他用处。
    所以许多人会误会命令模式的意图，以为它其实没什么用处，从而联想到其他设计模式 也没有用处。

这些误解都影响了设计模式在JavaScript语言中的发展。

JavaScript中的原型继承

1. 所有的数据都是对象
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
    JavaScript的根对象是Object.prototype对象。

    ```js
    var obj1 = new Object();
    var obj2 = {};

    console.log(Object.getPrototypeOf(obj1) === Object.prototype); // true
    console.log(Object.getPrototypeOf(obj2) === Object.prototype); // true
    ```

3. JavaScript对象会记住它的原型
4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型

## 工厂模式列表

1. 抽象工厂模式（Abstract Factory）
    定义: 提供一个创建一系列相关或相互依赖对象的接口，而无需制定它们具体的类。
    本质: 选择产品簇的实现。
2. 生成器模式（Builder）
    定义: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    本质：
        分离整体构建算法和部件构造。
        生成器模式的重心在于分离整体构建算法和部件构造，而分步骤构建对象不过是整体构建算法的一个简单实现，或者说是一个附带产物。

生成器模式与抽象工厂模式

这两个模式既相似又有区别，也可以组合使用。
    区别：抽象工厂模式的主要目的是创建产品簇，这个产品簇里面的单个产品就相当于是构成一个复杂对象的部件对象，抽象工厂对象创建完成后就立即返回整个产品簇；而生成器模式的主要目的是按照构造算法，一步一步来构建一个复杂的产品对象，桐城要等到整个构建过程结束以后没才会得到最终的产品对象。

组合使用：在生成器模式的Builder实现中，需要创建各个部件对象，而这些部件对象是有关联的，通常是构成一个复杂对象的部件对象。也就是说，Builder实现中，需要获取构成一个复杂对象的产品簇，就可以使用抽象工厂模式来实现。有抽象工厂模式负责部件对象创建，Builder实现里面则主要负责产品对象整体的构建了。

## 策略模式

策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。

```js
var strategies = {
    "S": function( salary ){
        return salary * 4;
    },
    "A": function( salary ){
        return salary * 3;
    },
    "B": function( salary ){
        return salary * 2;
    };
var calculateBonus = function(level, salary){
    return strategies[level](salary);
};
console.log(calculateBonus('S', 20000));
console.log(calculateBonus('A', 10000));
// 输出:80000 // 输出:30000
```

## 发布-订阅模式

发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。

优点：

一为时间上的解耦
二为对象之间的解耦。
还可以用来帮助实现一些别的设计模式，比如中介者模式。

缺点:

创建订阅者本身要消耗一定的时间和内存.
发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。
特别是有多个发布者和订阅者嵌套到一 起的时候，要跟踪一个 bug 不是件轻松的事情。

## 组合模式

组合模式: 用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更 小的“孙对象”构成的。

组合对象和叶对象会各自做自己正确的事情。--组合模式最重要的能力

使用场景：
    1. 代表对象的部分-整体层次结构。
    2. 对树中所有对象统一对待

组合模式可以让我们使用树形方式创建对象的结构，把相同的操作应用在组合对象和单个对象上。大多数情况下可以忽略掉两者的差别，用一致的方式来处理。

缺点：

每个对象看你起来与其他对象差不多，但区别会在运行时显现出来，会让代码难以理解；
    如果组合模式创建的对象太多，可能让系统负担不起。

## 模板方法模式(Template Method)

模板方法模式是一种只需使用继承就可以实现的非常简单的模式。

模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。
通常 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。
子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。

如果子类未实现父类要求实现的方法，可以`throw new Error('子类必须重写xxx方法')`来做检查。

模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。

```js
var brew = param.brew || function(){
    throw new Error( '必须传递 brew 方法' );
};
```

模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架， 程序员继承框架的结构之后，负责往里面填空，

钩子方法(hook)用来解决一些特殊的子类，不符合父类的执行顺序等。

## 享元模式(flyweight)

是一种用时间换空间的优化模式，为解决性能而生

核心: 运用共享技术来有效支持大量细粒度的对象

目标: 尽量减少共享对象的数量

享元模式要求将对象的属性分为内部状态和外部状态。划分内外部状态规则：

- 内部状态存储于对象内部
- 内部状态可以被一些对象共享
- 内部状态独立于具体的场景，通常不会变
- 外部状态取决于具体的场景，根据场景而变，外部状态不能共享

使用场景：

- 一个程序中使用了大量的相似对象
- 由于使用了大量的相似对象，造成很大的内存开销
- 对象的大多数状态都可以变为外部状态
- 剥离出对象的外部状态后，可以用相对较少的共享对象取代大量对象

思考：

创建出的共享对象在每次绑定事件后会执行自己的绑定时间还是会覆盖

## 职责链模式

定义: 使多个对象都有机会处理请求，避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，
连着这条链传递该请求，直到有一个对象处理它为止。

把大函数拆成小函数，去掉许多嵌套的条件分支语句

此外 Chain 的 prototype 中还有两个函数，它们的作用如下所示: // Chain.prototype.setNextSuccessor 指定在链中的下一个节点
// Chain.prototype.passRequest 传递请求给某个节点

```js
var Chain = function( fn ){
    this.fn = fn;
    this.successor = null;
};
Chain.prototype.setNextSuccessor = function( successor ){
    return this.successor = successor;
};
Chain.prototype.passRequest = function(){
    var ret = this.fn.apply( this, arguments );
    if ( ret === 'nextSuccessor' ){
        return this.successor && this.successor.passRequest.apply( this.successor, arguments );
    }
    return ret;
};


// 使用
var chainOrder500 = new Chain( order500 );
var chainOrder200 = new Chain( order200 );
var chainOrderNormal = new Chain( orderNormal );

chainOrder500.setNextSuccessor( chainOrder200 );
chainOrder200.setNextSuccessor( chainOrderNormal);

```

优点：

- 解耦了请求发送者和N个接收者之间的复杂关系

- 链中的节点可以灵活的拆分重组

- 可以手动指定起始节点

- 可以在链尾增加一个保底的接受者节点处理前面无法处理的请求

要避免过长的职责链带来的性能损耗

## 中介者模式

通过增加一个中介者对象，所有相关的对象都通过中介者来通信，而不是互相引用。当一个对象发生改变，只需通知中介者。

使网状的多对多关系变成相对简单的一对多关系

**作用**
    解除对象与对象之间的紧耦合关系。

**缺点**
    系统会增加一个中介者对象。对象之间复杂的交互性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身就是一个难以维护的对象。

**总结**
中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。
