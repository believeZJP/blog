---
title: 正则
date: 2019-01-22 16:36:06
updated: 2019-01-22 16:36:06
tags:
- 正则
- 教程
- 笔记
---
[参考链接](https://juejin.im/post/5bf174396fb9a049ca36f13d#heading-7)
[面试官！让我们聊聊正则](https://juejin.im/post/5b62717ee51d4519873f858a)

[正则表达式 - 元字符!!!](http://www.runoob.com/regexp/regexp-metachar.html)
一直以来正则都靠搜索，复制粘贴。今天开始学习，以后就可以自己写啦~~~

# 正则表达式是什么
正则表达式(Regular Expression)是一个描述字符模式的对象，使用正则表达式可以进行强大的模式匹配和文本检索与替换功能。
在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

正则表达式是处理字符串的利器，并提高工作效率，一个好的正则能够帮我们省去几十甚至上百行代码。
# 入门

**学习正则表达式最好方法是从例子开始，理解例子之后再对例子进行修改，实验。**


# 常用正则表达式
1. 姓名
    - 2-9位中文昵称： `^[\u4e00-\u9fa5]{2,9}$`
2. 验证密码
    - 只能是数字、字母、下划线，长度不限制: `^\w+$`
    - 允许 小写字母 a-z、大写字母 A-Z、数字 0-9、下划线 _、 连接符 -，且长度在 6-18 位数：
    `/^[a-zA-Z0-9_-]{6,18}$/`
    - 必须包含数字+小写字母+大写字母的密码，且长度在8-10位之间：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`
3. 验证 Email
    - 允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-+.] + @ + 允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-.] + . + 允许有一个字符符合 [A-Za-z0-9_] 之后可以有 [A-Za-z0-9_-.] 的邮箱：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
4. 验证身份证
    - 18 位身份证号，尾数是数字或者字母 X：`^(\d{6})(\d{4})(\d{2})(\d{2})(\d{3})([0-9]|X)$`
    - 15 或者 18 位身份证号，尾数可以是数字及 X 或者 x：`(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)`
5. 验证手机号
    - 以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码：`^1[3,4,5,7,8,9]\d{9}$`
    - 移动号码：`^134[0-8]\d{7}$|^(?:13[5-9]|147|15[0-27-9]|178|1703|1705|1706|18[2-478])\d{7,8}$`
    - 电信号码：`^(?:133|153|1700|1701|1702|177|173|18[019])\d{7,8}$`
    - 联通号码：`^(?:13[0-2]|145|15[56]|176|1704|1707|1708|1709|171|18[56])\d{7,8}|$`

# 基础
要想玩转正则首先要明白三大元素：`修饰符 元字符 量词`
例：var reg = /^\d$/g 这是一个简单点正则，下面我们来对三大元素一探究竟
1. 修饰符
- `g` - global 全局匹配（只要有匹配成功的结果一直匹配直到没有为止）
- `i` - ignoreCase 忽略大小写
- `m` - multiline 多行匹配

2. 元字符
元字符分为特殊元字符和普通元字符
普通元字符就是列入数组，字母等元素
常用特殊元字符如下：

- `\` 转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义的字符转变为普通字符）
- `.` 除了`\n`（换行符）以外的任意字符
- `\d` 匹配一个`0~9`之间的数字
- `\D` 匹配一个非`0~9`之间的数字（大写与小写字母组合正好是相反含义
- `\w` 匹配一个0~9或字母或_之间的一个字符
- `\s` 匹配一个任意空白字符
- `\b` 匹配一个边界符
- `x|y` 匹配x或者y中的一个
- `[a-z]` 匹配`a-z`中的任意一个字符
- `[^a-z]` 匹配非`a-z`中的任意一个字符
- `[x- yz]` 匹配x或y或z中的一个字符
- `[^xyz` 和上方相反
- `()` 整的小分组，匹配一个小分组（可以理解为大正则中的一个小正则）
- `^` 以某一个元字符开始
- `$` 以某一个元字符结束
- `?:` 只匹配不捕获
- `?=` 正向肯定预查
- `?!` 正向否定预查

3. 量词
量词主要的作用是用来描述元字符出现的次数 如下：

- `+` 让前面的元字符出现一到多次
- `?` 出现零到一次
- `*` 出现零到多次
- `{n}` 出现n次
- `{n,}` 出现n到多次
- `{n,m}` 出现n到m次

# 常用方法
JavaScript 正则默认： 正则匹配成功就会结束，不会继续匹配。如果想查找全部，就要加标识 `g`（全局匹配）

1. test()

规则：匹配字符串，匹配成功返回true，匹配失败返回false
语法：正则.test(字符串)
案例：
```js
var str = "123abc";
var re = /\D/; // 匹配非数字
if(re.test(str)) {
    console.log("不全是数字！");
} else {
    console.log("全是数字！");
}
```

2. search()
规则：匹配成功，返回成功的位置，失败返回-1
用法：字符串.search(正则)
案例：
```js
var str = "abcdef";
var re1 = /d/i;
var re2 = /h/i;
console.log(str.search(re1)); // 3
console.log(str.search(re2)); // -1
```

3. match()
规则：匹配成功，返回匹配成功的数组，匹配不成功，返回 null
用法：字符串.match(正则)
案例：
```js
var str = "123fadf321dfadf4fadf1";
var re = /\d+/g;
console.log(str.match(re)); //(4) ["123", "321", "4", "1"]
```

4. replace()
规则：匹配陈宫的字符串替换成新的字符串。
用法：字符串.replace(正则, 新的字符串)
案例：
```js
var str = 'aaa';
var re = /a+/g;
str = str.replace(re, "b");
console.log(str); // b
```

敏感词替换
```js
var s1 = '非诚勿扰在中国船的监视之下寸步难行';
var re = /非诚|中国船|监视之下/g;
s1.replace(re, function(str) {
    return '*'.repeat(str.length);
})
```

# 正则解析

看一个简单的正则：`^[a-z0-9_-]{6,12}$`

- ^表示匹配字符串的开始位置
- [a-z0-9_-]表示字符串的开头可以为`a-z`的字母, `0-9`的数字, `_`下划线, `-`连接符
    - [a-z] 表示匹配 a-z 中任意单个字母；
    - [0-9] 表示匹配 0-9 中任意单个数字；
    - [_] 表示匹配下划线；
    - [-] 表示匹配连接符 -。
    所以，将前面的连起来，[a-z0-9_-] 表示字符串可以包含数字、字母、_、- 这四种形式的字符串。
- {6, 12} 表示该字符串的长度为 6-12 位。
- `$`表示结束标志，`^` 表示开始

> `^` 与 `$` 同时使用，表示精确匹配。


综上：这个正则表达式的用途校验字符串只能包含小写字母，数字，下划线，连接字符，并且最长12位，最短6位。


## JavaScript 创建正则表达式
两种方式：

1. 用`/正则表达式/`两个斜杠来包裹要写的正则表达式
2. 构造函数创建
`var reg = new RegExp('\\d+', 'img')`
第一个参数是元字符并且\d这种特殊字符在这里面是普通字符，所以需要用\转义为特殊字符，第二个参数是修饰符



这两种的用途有区别，一般需要动态创建正则元字符采用构造函数创建，因为里面元字符是字符串拼接，常规固定写死正则采用字面量创建，例子如下：

`var reg = /^[a-z0-9_-]{6,12}$/`

这就是一条规则。

如何匹配一个字符串。这里用test方法

```js
var str = 'abc-cba_abc';
var reg = /^[a-z0-9_-]{6,12}$/;
console.log(reg.test(str)); // true

```
reg 通过 test() 方法去测试 str 是否符合 reg的规则，如果符合则返回 true，如果不符合则返回 false。
这里返回的是 true，因为我们的 str 是符合 reg 规则的。

### 小栗子🌰🌰🌰

```js
var str = "Cheer for yourself";
var reg1 = /^Cheer/;
var reg2 = /yourself$/;
var reg3 = /for/;
console.log(reg1.test(str));
console.log(reg2.test(str));
console.log(reg3.test(str));
```
 第一个判断该字符串是否以 Cheer 开头；
 第二个判断该字符串是否以 yourself 结尾；
 第三个判断该字符串是否包含 for。

## ()匹配子项

匹配子项，就是小括号`()`，也叫分组操作。
|表达式|	释义|	用法|
|-----|-------|------|
|(子表达式)|标记一个子表达式的开始和结束位置。|	(\w)\1 能匹配 deep 中的 ee|

`var re = /(\d+)(-)/g;`

分析这个正则：
- `/(\d+)/` 表示任意 1 个及以上的数字
- `/(-)/` 表示匹配字符 -
- `g` 表示匹配一次以上

所以这段正则的意思就是匹配一次及以上的 `数字-` 形式的字符串。 


```js
var str = "2018-11-28";
var re = /(\d+)(-)/g;
str = str.replace(re, function($0, $1, $2){
    // 第一个参数：$0（母亲)
    // 第二个参数：$1（第一个孩子）
    // 第三个参数：$2 (第二个孩子)
    console.log("$0：" + $0);
    console.log("$1：" + $1);
    console.log("$2：" + $2);
    return $1 + '.';
});
console.log(str); // 2018.11.28

```
console结果：
```js
$0：2018-
$1：2018
$2：-
$0：11-
$1：11
$2：-
2018.11.28
```
这里使用了 replace() 方法。
观察 Console 打印出来的结果，可以看出
`$0` 即是我们的正则 var re = /(\d+)(-)/g 去匹配 var str = "2018-11-28" 所得到的结果，
这里我们匹配成功了两次，即 2018- 及 11-；
`$1` 即是我们的一个小括号 (\d+) 的匹配结果，所以结果为 2018 以及 11；`$2` 即是我们的第二个小括号 (-) 的匹配结果，所以结果为 - 以及 -。
 最后，我们做的事情就是，将 $1 加上 `.`，并返回最终结果给 str，最终结果：`2018.11.28`。

另一个例子：
```js
var str = "abc";
var re = /(a)(b)(c)/;
console.log(str.match(re));
```
console结果：
```js
["abc", "a", "b", "c", index: 0, input: "abc", groups: undefined]
```


## []字符类
字符类，就是一组类似的元素 `[]` 这样的中括号的整体，代表一个字符。

**字符串包含中括号中任一字符即满足条件**

```js
var str1 = "abcd";
var re1 = /a[bcd]c/;
console.log(re1.test(str1)); // true

var str2 = "abc";
var re2 = /a[^bcd]c/;
console.log(re2.test(str2)); // false

var str3 = "a.c";
var re3 = /a[a-z0-9A-Z]c/;
console.log(re3.test(str3));  // false
```

解析：
- /a/：匹配字母 a
- /[bcd]/：匹配字母 bcd 中的一位
- /[d]：匹配字母 d
- ^ 如果写在 [] 里面的话，就代表排除的意思。在这里就代表着 a 和 c 中间不能是 bcd 中的任意一个
- /[a-z0-9A-Z]/：匹配小写字母 a-z，或者数字 0-9，或者大写字母 A-Z。即 a 与 c 之间只能是上面匹配地上的字符。