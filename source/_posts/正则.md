---
title: 正则
date: 2019-01-22 16:36:06
updated: 2019-01-22 16:36:06
tags:
- 正则
- 教程
- 笔记
---
[TOC]
[参考链接](https://juejin.im/post/5bf174396fb9a049ca36f13d#heading-7)
[面试官！让我们聊聊正则](https://juejin.im/post/5b62717ee51d4519873f858a)

[正则表达式 - 元字符!!!](http://www.runoob.com/regexp/regexp-metachar.html)
一直以来正则都靠搜索，复制粘贴。今天开始学习，以后就可以自己写啦~~~

# 正则表达式是什么
正则表达式(Regular Expression)是一个描述字符模式的对象，使用正则表达式可以进行强大的模式匹配和文本检索与替换功能。
在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

正则表达式是处理字符串的利器，并提高工作效率，一个好的正则能够帮我们省去几十甚至上百行代码。
# 入门

**学习正则表达式最好方法是从例子开始，理解例子之后再对例子进行修改，实验。**


# 常用正则表达式
1. 姓名
    - 2-9位中文昵称： `^[\u4e00-\u9fa5]{2,9}$`
2. 验证密码
    - 只能是数字、字母、下划线，长度不限制: `^\w+$`
    - 允许 小写字母 a-z、大写字母 A-Z、数字 0-9、下划线 _、 连接符 -，且长度在 6-18 位数：
    `/^[a-zA-Z0-9_-]{6,18}$/`
    - 必须包含数字+小写字母+大写字母的密码，且长度在8-10位之间：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`
3. 验证 Email
    - 允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-+.] + @ + 允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-.] + . + 允许有一个字符符合 [A-Za-z0-9_] 之后可以有 [A-Za-z0-9_-.] 的邮箱：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
4. 验证身份证
    - 18 位身份证号，尾数是数字或者字母 X：`^(\d{6})(\d{4})(\d{2})(\d{2})(\d{3})([0-9]|X)$`
    - 15 或者 18 位身份证号，尾数可以是数字及 X 或者 x：`(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)`
5. 验证手机号
    - 以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码：`^1[3,4,5,7,8,9]\d{9}$`
    - 移动号码：`^134[0-8]\d{7}$|^(?:13[5-9]|147|15[0-27-9]|178|1703|1705|1706|18[2-478])\d{7,8}$`
    - 电信号码：`^(?:133|153|1700|1701|1702|177|173|18[019])\d{7,8}$`
    - 联通号码：`^(?:13[0-2]|145|15[56]|176|1704|1707|1708|1709|171|18[56])\d{7,8}|$`

# 基础
要想玩转正则首先要明白三大元素：`修饰符 元字符 量词`
例：var reg = /^\d$/g 这是一个简单点正则，下面我们来对三大元素一探究竟
## 1. 修饰符
- `g` - global 全局匹配（只要有匹配成功的结果一直匹配直到没有为止）
- `i` - ignoreCase 忽略大小写
- `m` - multiline 多行匹配

## 2. 元字符
元字符分为特殊元字符和普通元字符
普通元字符就是列入数组，字母等元素
常用特殊元字符如下：

- `\` 转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义的字符转变为普通字符）


- `.` 除了`\n`（换行符）以外的任意字符
- `\d` 匹配一个`0~9`之间的数字
- `\D` 匹配一个非`0~9`之间的数字（大写与小写字母组合正好是相反含义
- `\w` 匹配一个0~9或字母或_之间的一个字符
- `\s` 匹配一个任意空白字符
- `\b` 匹配一个边界符
- `x|y` 匹配x或者y中的一个
- `[a-z]` 匹配`a-z`中的任意一个字符
- `[^a-z]` 匹配非`a-z`中的任意一个字符
- `[x- yz]` 匹配x或y或z中的一个字符
- `[^xyz` 和上方相反
- `()` 整的小分组，匹配一个小分组（可以理解为大正则中的一个小正则）
- `^` 以某一个元字符开始。例：`var reg = /^2/;` 表示开头必须是2，如果开始元字符放在[]里面 例：`[^]`表示非中括号种情况 相反含义
- `$` 以某一个元字符结束。例： `var reg = /2$/;` 表示结尾必须是2，如果是 `var reg = /^2$/;` 表示只能为2，因为2只代表一个元字符。
- `?:` 只匹配不捕获
- `?=` 正向肯定预查
- `?!` 正向否定预查
### 使用解析
- `()` 小分组
```
var reg = /^18|19$/

// 这个例子很多同学能够了解是18或者19开头 但是结尾呢？真的只匹配19么？ 其实并不是
// 正确的匹配除了18 19 还有181、189、819 这时候小分组就起到了作用如下

var reg = /^(18|19)$/

// 这里将18或19用()包裹起来，起到小分组的作用
// 这样这个正则只匹配18开头结尾或者19而不是181和189
```

- `\` 转义字符

> 将特殊元字符转换为普通字符，例：`var reg = /^2.3$/` 正常理解为匹配启示为2 结束为3中间是.的正则，但是在这里面.属于特殊元字符，意义是除了\n（换行符）以外的任意字符，所以不论是2.3/2+3/2s.3等等，只要是不·\n都匹配成功，所以为了这种需求就用到了转义字符\ 如下： `var reg = /^2\.3$/` 将特殊元字符.转义为真正的.元素，再次匹配只有2.3才能匹配成功 如下思考：

```js
var reg1 = /^\d$/
var reg2 = /^\\d$/
var reg3 = /^\\\d$/
var reg4 = /^\\\\d$/
```

首先reg1 表示0-9之间的数字 所以0-9都能匹配成功

reg2出现两个\ 不论是0-9 d \d都匹配失败，只有\\d才匹配成功，
原因在于第一个转义字符把第二个\转义为普通\，
此时第一个\也表示普通字符，所以只有匹配到`\\d`才生效

reg3出现三个\，此时大家一定会认为`\\\d`才是正确答案，非也，
此时的正确答案是\\[0-9]意思是\和0-9中任意一个数字，
原因在于第一个\将第二个转义，所以变为`\\ \d`分为了两部分，
\\为普通字符，而\d表示一个0~9之间的数字，所以正确答案是`\\[0-9]`

reg4出现四个\ 很多同学会认为正确答案一定是\\\[0-9], 很可惜，
正确的是`\\\\d`，原因是当第一个把第二个转义为普通字符时，
第三个又把第四个转义为普通字符，所以最后匹配为`\\\\d`

看到这里相信有一部分小伙伴已经晕了，
虽然在工作我们不会玩这种操作，但是要深刻理解转义字符，
在正则中如果你直接写 `var reg = /\/` 会报错，
因为正则中不能单独一个\出现，因为它是一个特殊元字符，
需要写至少两个\, 例如： `var reg = /^\\$/` 
正确的匹配结果为`\\`，所以牢记两个\代表真正的\，
到这里能搞明白的同学，相信转义字符已经完全掌握。

- 分组引用`\n`
分组引用的概念就是可以引用大正则中指定的小正则规则，例如：
```
var reg = /^([a-z])([a-z])\2([a-z])$/
// 符合的字符串：book week http ...​
```
> 具体上面的例子理解为\2代表着第二个小正则规则的完全引用，就是和第二个小正则([a-z])一样，可以减少正则的复杂度和处理多次重复规则

- 匹配字符 `[]`
```js
var reg = /^[a-zA_Z0-9_]$/
// 这个正则和等价于\w 就是匹配一个0~9或字母或_之间的一个字符
// 而正则[xyz]中的xyz分别代表a-z、A_Z、0-9,xyz只是一个代表标识，
// 可以有xyzhw各种组合
// 就像这个例子中有下划线_一样四个的匹配
// 有一个重点补充，在[]中的特殊元字符一般都代表本身含义，如下
var reg = /^[.?+&]$/
// 代表着匹配. .? ?+ ...等等
```

- 边界符`\b` ???
匹配一个单词边界，也就是指单词和空格间的位置（边界主要是单词的左右两边） 例如：
```js
var reg = /er\b/
// 可以匹配never中的er，但是不能匹配verb中的er
var reg = /\b\w+\b/g
// 能匹配字母数字和下划线与单词边界 'my blog is www.ngaiwe.com'
// 能匹配 'my'、'blog'、'is'、'www'、'ngaiwe'、'com'
```
- 只匹配不捕获 `?`
下面举一个例子，但是涉及到捕获内容，如果同学们不太明白，可以先跳过此处，看完下面捕获，再返回来看
```js
var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/g
var str = '110105199001220613'
console.log(reg.exec(str))
// 打印结果为 "110105199001220613", "110105", "1990", "01", "22", "1", "3"

var reg = /^(\d{6})(?:\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/g
// 打印结果为 "110105199001220613", "110105", "01", "22", "1", "3"
// 会将第二个小分组只匹配，不捕获

```
- 10.正向肯定预查 `?=`
这个概念比较难理解，用于就是为了匹配一个元素后面是的元素是否符合相应规则，但是并不消耗这个规则，例子1：
```js
var reg = /windows(?=95|98|NT|2000)/
var str1 = 'windows2000'
var str2 = 'windowsxp'

console.log(reg.test(str1))
console.log(reg.test(str2))
// str1 为true str2 为false

console.log(reg.exec(str1))
console.log(reg.exec(str2))
// 能捕获到str1 并且捕获结果时windows 并没有将2000也同时捕获
// 说明正向预查只负责匹配相应规则

//-------例子2-----------

var reg1 = /win(?=d)dows/
var reg2 = /win(d)dows/
var str = 'windows'
console.log(reg1.test(str))
console.log(reg2.test(str))
// reg1 返回true reg2返回 false
// 原因是正向预查只负责匹配，不消耗字符，也就是并不会匹配为里面规则的字符
// reg1 相当于匹配windows并且符合win后面第一个出现的是d
// reg2 相当于匹配winddows


```

- 11.正想否定预查 `?!`
和正向肯定预查相反，匹配不符合规则的正则





## 3. 量词
量词主要的作用是用来描述元字符出现的次数 如下：

- `+` 让前面的元字符出现一到多次
- `?` 出现零到一次
- `*` 出现零到多次
- `{n}` 出现n次
- `{n,}` 出现n到多次
- `{n,m}` 出现n到m次

# 常用方法
JavaScript 正则默认： 正则匹配成功就会结束，不会继续匹配。如果想查找全部，就要加标识 `g`（全局匹配）

1. test()

规则：匹配字符串，匹配成功返回true，匹配失败返回false
语法：正则.test(字符串)
案例：
```js
var str = "123abc";
var re = /\D/; // 匹配非数字
if(re.test(str)) {
    console.log("不全是数字！");
} else {
    console.log("全是数字！");
}
```

2. search()
规则：匹配成功，返回成功的位置，失败返回-1
用法：字符串.search(正则)
案例：
```js
var str = "abcdef";
var re1 = /d/i;
var re2 = /h/i;
console.log(str.search(re1)); // 3
console.log(str.search(re2)); // -1
```

3. match()
规则：匹配成功，返回匹配成功的数组，匹配不成功，返回 null
用法：字符串.match(正则)
案例：
```js
var str = "123fadf321dfadf4fadf1";
var re = /\d+/g;
console.log(str.match(re)); //(4) ["123", "321", "4", "1"]
```

4. replace()
规则：匹配陈宫的字符串替换成新的字符串。
用法：字符串.replace(正则, 新的字符串)
案例：
```js
var str = 'aaa';
var re = /a+/g;
str = str.replace(re, "b");
console.log(str); // b
```

敏感词替换
```js
var s1 = '非诚勿扰在中国船的监视之下寸步难行';
var re = /非诚|中国船|监视之下/g;
s1.replace(re, function(str) {
    return '*'.repeat(str.length);
})
```

# 正则解析

看一个简单的正则：`^[a-z0-9_-]{6,12}$`

- ^表示匹配字符串的开始位置
- [a-z0-9_-]表示字符串的开头可以为`a-z`的字母, `0-9`的数字, `_`下划线, `-`连接符
    - [a-z] 表示匹配 a-z 中任意单个字母；
    - [0-9] 表示匹配 0-9 中任意单个数字；
    - [_] 表示匹配下划线；
    - [-] 表示匹配连接符 -。
    所以，将前面的连起来，[a-z0-9_-] 表示字符串可以包含数字、字母、_、- 这四种形式的字符串。
- {6, 12} 表示该字符串的长度为 6-12 位。
- `$`表示结束标志，`^` 表示开始

> `^` 与 `$` 同时使用，表示精确匹配。


综上：这个正则表达式的用途校验字符串只能包含小写字母，数字，下划线，连接字符，并且最长12位，最短6位。


## JavaScript 创建正则表达式
两种方式：

1. 用`/正则表达式/`两个斜杠来包裹要写的正则表达式
2. 构造函数创建(不推荐)
`var reg = new RegExp('\\d+', 'img')`
第一个参数是元字符并且\d这种特殊字符在这里面是普通字符，所以需要用\转义为特殊字符，第二个参数是修饰符



这两种的用途有区别，一般需要动态创建正则元字符采用构造函数创建，因为里面元字符是字符串拼接，常规固定写死正则采用字面量创建，例子如下：

`var reg = /^[a-z0-9_-]{6,12}$/`

这就是一条规则。

如何匹配一个字符串。这里用test方法

```js
var str = 'abc-cba_abc';
var reg = /^[a-z0-9_-]{6,12}$/;
console.log(reg.test(str)); // true

```
reg 通过 test() 方法去测试 str 是否符合 reg的规则，如果符合则返回 true，如果不符合则返回 false。
这里返回的是 true，因为我们的 str 是符合 reg 规则的。

### 小栗子🌰🌰🌰

```js
var str = "Cheer for yourself";
var reg1 = /^Cheer/;
var reg2 = /yourself$/;
var reg3 = /for/;
console.log(reg1.test(str));
console.log(reg2.test(str));
console.log(reg3.test(str));
```
 第一个判断该字符串是否以 Cheer 开头；
 第二个判断该字符串是否以 yourself 结尾；
 第三个判断该字符串是否包含 for。

## ()匹配子项

匹配子项，就是小括号`()`，也叫分组操作。
|表达式|	释义|	用法|
|-----|-------|------|
|(子表达式)|标记一个子表达式的开始和结束位置。|	(\w)\1 能匹配 deep 中的 ee|

`var re = /(\d+)(-)/g;`

分析这个正则：
- `/(\d+)/` 表示任意 1 个及以上的数字
- `/(-)/` 表示匹配字符 -
- `g` 表示匹配一次以上

所以这段正则的意思就是匹配一次及以上的 `数字-` 形式的字符串。 


```js
var str = "2018-11-28";
var re = /(\d+)(-)/g;
str = str.replace(re, function($0, $1, $2){
    // 第一个参数：$0（母亲)
    // 第二个参数：$1（第一个孩子）
    // 第三个参数：$2 (第二个孩子)
    console.log("$0：" + $0);
    console.log("$1：" + $1);
    console.log("$2：" + $2);
    return $1 + '.';
});
console.log(str); // 2018.11.28

```
console结果：
```js
$0：2018-
$1：2018
$2：-
$0：11-
$1：11
$2：-
2018.11.28
```
这里使用了 replace() 方法。
观察 Console 打印出来的结果，可以看出
`$0` 即是我们的正则 var re = /(\d+)(-)/g 去匹配 var str = "2018-11-28" 所得到的结果，
这里我们匹配成功了两次，即 2018- 及 11-；
`$1` 即是我们的一个小括号 (\d+) 的匹配结果，所以结果为 2018 以及 11；`$2` 即是我们的第二个小括号 (-) 的匹配结果，所以结果为 - 以及 -。
 最后，我们做的事情就是，将 $1 加上 `.`，并返回最终结果给 str，最终结果：`2018.11.28`。

另一个例子：
```js
var str = "abc";
var re = /(a)(b)(c)/;
console.log(str.match(re));
```
console结果：
```js
["abc", "a", "b", "c", index: 0, input: "abc", groups: undefined]
```


## []字符类
字符类，就是一组类似的元素 `[]` 这样的中括号的整体，代表一个字符。

**字符串包含中括号中任一字符即满足条件**

```js
var str1 = "abcd";
var re1 = /a[bcd]c/;
console.log(re1.test(str1)); // true

var str2 = "abc";
var re2 = /a[^bcd]c/;
console.log(re2.test(str2)); // false

var str3 = "a.c";
var re3 = /a[a-z0-9A-Z]c/;
console.log(re3.test(str3));  // false
```

解析：
- /a/：匹配字母 a
- /[bcd]/：匹配字母 bcd 中的一位
- /[d]：匹配字母 d
- ^ 如果写在 [] 里面的话，就代表排除的意思。在这里就代表着 a 和 c 中间不能是 bcd 中的任意一个
- /[a-z0-9A-Z]/：匹配小写字母 a-z，或者数字 0-9，或者大写字母 A-Z。即 a 与 c 之间只能是上面匹配地上的字符。